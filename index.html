<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>1- git init </h1>
    <br>
    <p>Cette commande initialise un nouveau dépôt Git. Elle crée un répertoire .git dans le répertoire courant, contenant tous les fichiers et répertoires nécessaires au dépôt Git. Cela transforme le répertoire courant en un dépôt Git, permettant de commencer à suivre les versions des fichiers.</p>
    <br>
    <br>
    <h1>2- git clone </h1>
    <br>
    <p>Cette commande clone un dépôt existant. Elle crée une copie locale d'un dépôt distant (ou local). Par exemple, git clone https://github.com/utilisateur/projet.git créera une copie du dépôt hébergé sur GitHub dans un nouveau répertoire nommé projet.</p>
    <br>
    <br>
    <h1>3 -git add </h1>
    <br>
    <p>
        La commande git add ajoute des modifications dans l'index (ou la "staging area"). Cela signifie que les fichiers spécifiés seront inclus dans le prochain commit. Par exemple, git add fichier.txt ajoute fichier.txt à l'index.
        </p>
        <br>
        <br>
        <h1>4- git commit </h1>
        <br>
        <p>Cette commande enregistre les modifications ajoutées à l'index dans l'historique des versions du dépôt. Chaque commit est accompagné d'un message de commit descriptif. Par exemple, git commit -m "Message de commit" enregistre les modifications en cours avec le message spécifié.</p>
        <br>
        <br>
        <h1>5 -git status </h1>
        <br>
        <p>git status affiche l'état actuel du dépôt, indiquant les fichiers qui ont été modifiés, lesquels sont dans l'index et lesquels ne sont pas suivis par Git. Cela aide à voir ce qui doit être ajouté, commité ou ignoré.</p>
        <br>
        <br>
        <h1>6- git diff </h1>
        <br>
        <p>Cette commande montre les différences entre les fichiers dans l'index et ceux dans l'historique des versions, ou entre l'index et les fichiers non indexés. Par exemple, git diff sans arguments montre les différences entre les fichiers non indexés et l'index.</p>
        <br>
        <br>
        <h1>7- git log </h1>
        <br>
        <p>git log affiche l'historique des commits du dépôt, montrant les messages de commit, les dates et les auteurs des commits. Par exemple, git log affiche tous les commits, tandis que git log --oneline affiche chaque commit sur une seule ligne pour une vue plus compacte.</p>
        <br>
        <br>
        <h1>8- git branch </h1>
        <br>
        <p>git branch sert à gérer les branches dans un dépôt. Utilisé sans arguments, il liste toutes les branches locales. Avec un nom de branche comme argument, git branch nom_branche crée une nouvelle branche appelée nom_branche.</p>
        <br>
        <br>
        <h1>9- git checkout </h1>
        <br>
        <p>git checkout est utilisé pour basculer entre les branches ou pour restaurer des fichiers dans l'index ou l'historique des versions. Par exemple, git checkout nom_branche change la branche courante à nom_branche, tandis que git checkout -- fichier.txt restaure fichier.txt à son état dans l'index ou dans une version précédente.</p>
        <br>
        <br>
        <h1>10- git merge </h1>
        <br>
        <p> Cette commande fusionne les modifications de la branche spécifiée dans la branche courante. Par exemple, si vous êtes sur la branche main et que vous exécutez git merge dev, cela fusionnera les modifications de la branche dev dans main.</p>
        <br>
        <br>
        <h1>11-  Différence entre git merge et git rebase </h1>
        <br>
        <p>git merge combine deux branches en créant un nouveau commit de fusion, conservant ainsi l'historique des deux branches intact.
            Tandisque git rebase réapplique les commits d'une branche sur une autre en réécrivant l'historique. Cela crée une séquence de commits linéaire. Par exemple, git rebase main sur la branche feature applique les commits de feature après ceux de main, en réécrivant les commits de feature comme s'ils avaient été créés après ceux de main.
            </p>
        <br>
        <br>
        <h1>12- git stash </h1>
        <br>
        <p>git stash enregistre les modifications non commitées de l'index et du répertoire de travail dans une pile temporaire, permettant de revenir à un état de travail propre. Par exemple, git stash sauvegarde les modifications et git stash apply réapplique les modifications sauvegardées.</p>
        <br>
        <br>
        <h1>13- git fetch </h1>
        <br>
        <p>git fetch récupère les modifications depuis le dépôt distant mais ne les fusionne pas avec la branche courante. Il met à jour les références locales aux branches distantes. Par exemple, git fetch origin récupère les modifications depuis le dépôt origin.</p>
        <br>
        <br>
        <h1>14- git pull </h1>
        <br>
        <p>git pull récupère les modifications depuis le dépôt distant et les fusionne avec la branche courante. C'est une combinaison de git fetch et git merge. Par exemple, git pull origin main récupère et fusionne les modifications de la branche main du dépôt distant origin.</p>
        <br>
        <br>
        <h1>15- git push </h1>
        <br>
        <p>git push envoie les commits locaux à un dépôt distant. Par exemple, git push origin main           pousse les commits de la branche main locale vers la branche main du dépôt distant origin.</p>
        <br>
        <br>
        <h1>16-  git remote </h1>
        <br>
        <p>git remote gère les dépôts distants. Utilisé sans arguments, il liste les dépôts distants configurés. Par exemple, git remote add origin https://github.com/utilisateur/projet.git ajoute un dépôt distant nommé origin. git remote remove origin supprime ce dépôt distant.</p>
</body>
</html>